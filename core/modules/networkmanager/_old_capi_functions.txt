
	extern "C"
	{
		/**
		 * @brief
		 * Sends a PRIVMSG to the irc server.
		 * 
		 * @param target
		 * Target can be either the name of a channel or a user.
		 * 
		 * @param message
		 * The message to send.
		 */
		void ircPrivMsg(void *network, const int8 *target,
						const int8 *message)
		{
			NetworkManager *nm = (NetworkManager *)network;
			if ( NULL == nm )
			{
				return;
			}
			
			std::string ircMessage("PRIVMSG ");
			ircMessage += target;
			ircMessage += " :";
			ircMessage += message;
			ircMessage += "\r\n";
			
			nm->sendMessage(ircMessage);
		}
		
		/**
		 * @brief
		 * Sends a raw string to the irc server.
		 * 
		 * @param network
		 * IRC network to send to.
		 * 
		 * @param rawCommand
		 * The string to send. Note that CRLF ("\r\n") isn't added, so you
		 * might need to add that to the end of the string.
		 */
		void ircSendRaw(void *network, const int8 *rawCommand)
		{
			NetworkManager *nm = (NetworkManager *)network;
			if ( NULL == nm )
			{
				return;
			}
			
			nm->sendMessage(std::string(rawCommand));
		}

		/**
		 * @brief
		 * Retrieves the nick of the bot/client.
		 * 
		 * @param network
		 * IRC network to look at.
		 * 
		 * @param destName
		 * String buffer that the nickname will be written to.
		 * 
		 * @param maxNameLength
		 * Size of the destination buffer in bytes.
		 * 
		 * @return
		 * RES_OK on success or an error code on failure.
		 */		
		Result cacheGetBotNickName(void *network, int8 *destName,
							uint32 maxNameLength)
		{
			Result res = RES_INVALID_PARAMETER;
			
			if ( NULL != network
				 && NULL != destName
				 && maxNameLength > 0 )
			{
				res = ((NetworkManager *)network)->getBotNickName(
														destName,
														maxNameLength);
			}
			
			return res;
		}
		
		/**
		 * @brief
		 * Retrieves the topic of a channel.
		 * 
		 * @param network
		 * IRC network to look at.
		 * 
		 * @param channel
		 * The channel from which the topic will be retrieved.
		 * 
		 * @param destTopic
		 * String buffer that the topic will be written to.
		 * 
		 * @param maxTopicSize
		 * Size of the destination buffer in bytes.
		 * 
		 * @return
		 * RES_OK on success or an error code on failure.
		 */
		Result cacheGetTopic(void *network, const int8 *channel,
					int8 *destTopic, uint32 maxTopicSize)
		{
			Result res = RES_INVALID_PARAMETER;
			
			if (   NULL != network
				&& NULL != channel
				&& NULL != destTopic
				&& 0 < maxTopicSize )
			{
				res = ((NetworkManager *)network)->getTopic(channel,
													destTopic,
													maxTopicSize);
			}
			
			return res;
		}

		/**
		 * @brief
		 * Retrieve the user count for a channel.
		 * 
		 * @param network
		 * IRC network to look at
		 * 
		 * @param channel
		 * The channel to retrieve the user count from.
		 * 
		 * @param destUserCount
		 * Pointer to a uint32 that will receive the user count.
		 * 
		 * @return
		 * RES_OK on success or an error code on failure.
		 */		
		Result cacheGetChannelUserCount(void *network,
										const int8 *channel,
										uint32 *destUserCount)
		{
			Result res = RES_INVALID_PARAMETER;
			
			if ( NULL != network
				 && NULL != channel
				 && NULL != destUserCount )
			{
				res = ((NetworkManager *)network)->getChannelUserCount(
														channel,
														destUserCount);
			}
			
			return res;
		}
		
		/**
		 * @brief
		 * Check if a user is in a channel.
		 * 
		 * @param network
		 * IRC network to look at.
		 * 
		 * @param channel
		 * Channel to look in.
		 * 
		 * @param userNick
		 * Nickname of the user to look for.
		 * 
		 * @param userIsInChannel
		 * Set to TRUE if the user is in the specified channel
		 * (according to the cache), FALSE otherwise.
		 * 
		 * @return
		 * RES_OK on success, RES_NOTFOUND if the channel can't be
		 * found or another error code if something else goes wrong.
		 */
		Result cacheIsUserInChannel(void *network, const int8 *channel,
								const int8 *userNick,
								bool32 *userIsInChannel)
		{
			Result res = RES_INVALID_PARAMETER;
			
			if ( NULL != network
				&& NULL != channel
				&& NULL != userNick
				&& NULL != userIsInChannel )
			{
				res = ((NetworkManager *)network)->isUserInChannel(
													channel,
													userNick,
													userIsInChannel);
			}
			
			return res;
		}
		
		/**
		 * @brief
		 * Retrieves various information about a specific channel that
		 * the bot is in.
		 * 
		 * @param[in] network
		 * The IRC network of the channel.
		 * 
		 * @param[in] channel
		 * The name of the channel (including '#' character).
		 * 
		 * @param[out] channelInfo
		 * Will point to a dynamically allocated copy of the internal
		 * channel info object stored in the cache. Remember to destroy
		 * it when you don't need it anymore.
		 * 
		 * @remarks
		 * The channel info object is a read only snapshot of the
		 * channel, and will not be updated automatically.
		 * To get current information, you need to continuously retrieve
		 * new channel info objects. But don't forget to destroy the old
		 * ones, otherwise you will cause memory leakage.
		 * 
		 * @return
		 * RES_OK on success, an error code otherwise.
		 */
		Result cacheCreateChannelInfoFromChannelName(void *network,
							const int8 *channel,
							const void **channelInfo)
		{
			Result res = RES_INVALID_PARAMETER;
			
			if ( NULL != network
				&& NULL != channel )
			{
				res = ((NetworkManager *)network)->getChannelInfo(
					network, channel, channelInfo);
			}
			
			return res;
		}
		
		/**
		 * @brief
		 * Deallocates a channel info object.
		 * 
		 * @param channelInfo
		 * ChannelInfo object to destroy.
		 * 
		 * @sa
		 * cacheCreateChannelInfoFromChannelName
		 */
		void cacheDestroyChannelInfo(void *channelInfo)
		{
			/// @todo Move deletion into ircnetworkcache,
			/// cast to (Channel *)
			if ( NULL != channelInfo )
			{
				delete channelInfo;
			}
		}
	}
